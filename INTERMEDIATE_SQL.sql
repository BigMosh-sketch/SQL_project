-- SQL FUNCTIONS---
 --TYPES OF SQL FUNCTIONS---
-- SINGLE ROW FUNCTIONS & MULTIPLE ROW FUNCTION--
 --1.SINGLE ROW FUNCTIONS--
   -- NUMERIC, STRINGS, DATE/TIME, NULL --
		-- STRING FUNCTIONS--
		--A.MANIPULATION (CONCAT, UPPER, LOWER,TRIM,REPLACE)
		--B. CALCULATION (LEN)
		--C. STRING EXTRACTION (LEFT,RIGHT,SUBSTRING)
		 
		  -- CONCAT
SELECT CONCAT(FIRSTNAME,' ',LastName) 
	FROM SALES.Customers
SELECT FIRSTNAME + ' '+ LastName AS FULLNAME
	FROM SALES.Customers
	-- UPPER
SELECT UPPER ( CONCAT(FIRSTNAME,' ',LastName) ) AS FULL_NAME
	FROM SALES.Customers
	--LOWER
SELECT LOWER(CONCAT(FIRSTNAME,' ',LastName)) AS FULL_NAME
	FROM SALES.Customers
	-- TRIM
SELECT TRIM(PRODUCT) 
	FROM SALES.Products
	--REPLACE
SELECT  
	'234-567-8766' AS OLD,
	REPLACE('234-567-8766','-',' ') AS NEW
SELECT 
	'REPORT.TXT' AS OLD,
	REPLACE('REPORT.TXT','.TXT','.CSV') AS NEW

	 -- CALCULATION (LEN)
SELECT FIRSTNAME,
       LEN(FIRSTNAME)
	FROM SALES.Customers
	--STRING EXTRACTION (LEFT,RIGHT, SUBSTRING)
	 -- LEFT 
SELECT  
	FIRSTNAME,
	LEFT(FIRSTNAME,2)
	FROM SALES.CUSTOMERS

	-- RIGHT
SELECT 
	FIRSTNAME,
	RIGHT(FIRSTNAME,2)
	FROM SALES.Customers

	-- SUBSTRING
SELECT 
	FIRSTNAME,
	SUBSTRING(FIRSTNAME,3,2)
	FROM SALES.CUSTOMERS

  -- NUMERIC (ROUNDING, ABS, CEILING,FLOOR)--
		--ROUND-
SELECT 
	123.444,
	ROUND(123.449,1)

	 --ABS--
SELECT 
	-1234 ,
	ABS(-1234),
	-- CEILING--
SELECT 
	123.44,
	CEILING(123.44)
	 --FLOOR--
SELECT 
	123.44,
	FLOOR(123.44)

	 -- DATE & TIME --
	 -- PART EXTRACTION( DAY, MONTH, YEAR, DATEPART, DATENAME, DATETRUNC,EOMONTH)
SELECT 
	ORDERDATE,
	SHIPDATE,
	CREATIONTIME
	FROM SALES.Orders

SELECT 
	ORDERDATE,
	DAY(OrderDate) AS DAY1,
	SHIPDATE,
	MONTH(ORDERDATE) MONTH,
	YEAR(ORDERDATE) YEAR,
	CREATIONTIME,
	GETDATE() TODAY,
	DATEPART(YEAR,ORDERDATE) YEAR1,
	DATEPART(MONTH,SHIPDATE) MONTH1,
	DATEPART(DAY,ORDERDATE) DAY1
	FROM SALES.Orders
SELECT 
	DATEPART(HOUR,CreationTime) HOUR1,
	DATEPART(WEEK,CreationTime) WEEK1,
	DATEPART(MINUTE,CreationTime) MINUTES1,
	DATEPART(SECOND,CreationTime) SECOND1,
	DATENAME(MONTH,ORDERDATE) NAME1,
	DATENAME(WEEKDAY,ORDERDATE) DAY1,
	DATENAME(YEAR,ORDERDATE) YEAR1,
	CreationTime
	FROM SALES.Orders
	-- DATETRUNC
SELECT 
	CREATIONTIME,
	DATETRUNC(MINUTE,CREATIONTIME),
	DATETRUNC(HOUR,CREATIONTIME),
	DATETRUNC(DAY,CREATIONTIME),
	DATETRUNC(MONTH,CREATIONTIME),
	DATETRUNC(YEAR,CREATIONTIME)
	FROM SALES.Orders
	--EOMONTH (END OF THE MONTH)

SELECT 
	EOMONTH(CREATIONTIME),
	CreationTime
	FROM SALES.Orders

	-- DATE AGGREGRATE 
	-- How many order was placed in a month 
SELECT 
      DATETRUNC(MONTH,ORDERDATE) MONTH1,
	  COUNT(*)
	FROM SALES.ORDERS
	GROUP BY  DATETRUNC(MONTH,ORDERDATE)
	
SELECT 
      DATENAME(MONTH,ORDERDATE) MONTH,
	  COUNT(*) N
	FROM SALES.ORDERS
	GROUP BY  DATENAME(MONTH,ORDERDATE)
	--How many order was placed in a year
SELECT 
      DATETRUNC(year,ORDERDATE) YEAR_,
	  COUNT(*) NR_OF_ORDER
	FROM SALES.ORDERS
	GROUP BY  DATETRUNC(year,ORDERDATE)
SELECT
	YEAR(ORDERDATE) YEAR_ ,
	COUNT(*) NR_OF_ORDER
	FROM SALES.ORDERS
	GROUP BY YEAR(ORDERDATE)

SELECT
     *
	 FROM SALES.Orders
	 WHERE MONTH(ORDERDATE) = 2
	 
	 -- DATE FORMAT --
	 YYYY-MM-dd HH-mm-ss
	 2025-08-20
	  -- Formating & Casting---
	 
SELECT (ORDERDATE),
    FORMAT(OrderDate,'ddd/MMM/yyyy','ja-JP') AS FORMATED_Date,
	FORMAT(ORDERDATE, 'yyyy/MMM/ddd','fr-FR') AS FORMATED_DATE
	 FROM SALES.ORDERS

-- Show creationTime using the following format:
-- Day Wed Jan Q1 2025 12:34:56 PM

SELECT 
      productID,
      orderdate,
      CreationTime,
	  'DAY '+ format(creationTime,'ddd MMM')+' Q'+ DATENAME(QUARTER,CreationTime) +' '+FORMAT(CreationTime,'yyyy HH:mm:ss tt') as Formated_Date
	  FROM Sales.orders
	  --Formating Aggregation--
	   --formatting date--
SELECT 
	FORMAT(ORDERDATE, 'MMM yyyy') AS  DATE_NEW,
	COUNT(*) FREQUENCY
	FROM SALES.Orders
	GROUP BY FORMAT(OrderDate, 'MMM yyyy')

	--formating Aggregation
	-- formatting numeric
	--FORMAT(VALUE,DATAFORMAT)
SELECT
	FORMAT(123.443,'P') as Percent
UNION ALL
SELECT 
 FORMAT(123.445,'N') 

 ---- CONVERT---
 -- CONVERT(DATATYPE,VALUE)
 SELECT
 CONVERT(INT,'123') AS [STRING TO INT CONVERT ]

 SELECT 
 CONVERT(TIME,CREATIONTIME)
 FROM SALES.Orders

 --CAST--
    --CAST(VALUE AS DATATYPE)
 SELECT 
 CAST('123' AS INT)

 SELECT 
 CAST('2025-08-23' AS DATE)
 SELECT 
 CAST(CREATIONTIME AS TIME)
 FROM SALES.Orders

  -----------------------DATE & TIME FUNCTION --------------
  -------------- DATEADD(PART,INTERVAL,DATE)

SELECT
   DATEADD(YEAR,3,'2025-04-06')

SELECT 
   DATEADD(YEAR,3,CREATIONTIME) NEW_YEAR,
   DATEADD(MONTH,2,CREATIONTIME) NEW_MONTH,
   DATEADD(DAY,4,CREATIONTIME) NEW_DAY
	FROM SALES.ORDERS
 
 ---- DATEDIFF(PART,START_DATE,END_DATE)
 SELECT *
	FROM SALES.Employees

SELECT
	CONCAT(FIRSTNAME,' ',LASTNAME) FULL_NAME,
	BIRTHDATE,
	DATEDIFF(YEAR,BirthDate,GETDATE()) AGE
	FROM SALES.Employees


/* FIND THE AVERAGE SHIPPING DURATION IN DAYS FOR EACH MONTH */

SELECT * 
	FROM SALES.ORDERS

SELECT
	FORMAT(ShipDate, 'MMM-yyyy'),
	AVG(DATEDIFF(DAY,ORDERDATE,SHIPDATE))
	FROM SALES.Orders
	GROUP BY FORMAT(ShipDate, 'MMM-yyyy')

/* FIND THE NUMBER OF DAYS BETWEEN EACH ORDER AND  THE PREVIOUS DATE 
	TIME GAP ANALYSIS*/
SELECT 
	ORDERDATE,
	LAG(ORDERDATE) OVER (ORDER BY ORDERDATE) PREVIOUS_DATE,
	DATEDIFF(DAY,LAG(ORDERDATE) OVER (ORDER BY ORDERDATE),ORDERDATE)
	FROM SALES.ORDERS

	-- DATE VALIDATION--
	-- ISDATE--

SELECT 
	ORDERDATE,
	ISDATE(ORDERDATE)
FROM 
(
	SELECT '2025-08-20' AS ORDERDATE 
	UNION
	SELECT '2025-08-21'
	UNION
	SELECT '2025-08-23'
)
	
	-- USES OF NULL CASE IN SQL
	 -- ISNULL(VALUE,'SET VALUE') OR ISNULL(VALUE,ANOTHER VALUE) IS USED TO REPLACE NULL VALUE IN A TABLE
	 -- COALESCE(VALUE1,VALUE2,VALUE3,...) IS USED TO REPLACE NULL VALUE IN A TABLE

SELECT *
	fROM SALES.Employees
	WHERE LastName IS NULL

SELECT
	EMPLOYEEID,
	FirstName,
	LastName,
	ISNULL(LASTNAME,'OLA') AS LASTNAME
	fROM SALES.Employees

 -- DISPLAY THE FULLNAME OF CUSTOMERS IN A SINGLE FIELD 
 -- BY MERGING THERI FIRST AND LAST NAMES,
 -- AND ADD 10 BONUS SCORE TO EACH CUSTOMER'S SCORE.
SELECT *
	FROM SALES.CUSTOMERS

 SELECT 
	CONCAT(FIRSTNAME,' ',LASTNAME),
	SCORE,
	ISNULL(SCORE,0),
	ISNULL(SCORE,0) + 10
	FROM SALES.Customers
/* SORT THE CUSTOMER FROM THE LOWEST TO HIGHEST SCORES,
WITH NULLS APPEARING LAST */

SELECT
	CUSTOMERID,
	SCORE,
	CASE
	WHEN SCORE IS NULL THEN 1
	ELSE 0
	END
	FROM SALES.CUSTOMERS
	ORDER BY CASE
	WHEN SCORE IS NULL THEN 1
	ELSE 0
	END,SCORE
 
	
   -- NULLIF(VALUE1,VALUE2)-- USED TO ADD NULL VALUE TO A CELL IF THE TWO VALUE ARE EQUAL
	-- FIND THE SALES PRICE FOR EACH ORDER BY DIVIDING SALES BY QUANTITY
SELECT 
	CUSTOMERID,
	SALES,
	QUANTITY,
	SALES/NULLIF(QUANTITY,0) AS PRICE
	FROM SALES.ORDERS

--list all details of customers who have not placed orders.
SELECT 
	SC.*,
	ORDERID
	FROM SALES.ORDERS AS SO
	RIGHT JOIN SALES.CUSTOMERS AS SC
	ON SO.CUSTOMERID = SC.CUSTOMERID
	where SO.ORDERID IS  NULL

 -- CASE STATEMENT IN SQL
 --GENERATE A REPORT SHOWING THE TOTAL SALES FOR EACH CATEGORY
 -- HIGH: IF THE SALES IS HIGHER THAN 50
 --MEDIUM: IF THE SALES BETWEEN 20 AND 50
 --LOW: IF THE SALES IS EQUAL OR LOWER THAN 20
 -- SORT FROM THE HIGHEST TO LOWEST SALES


SELECT 
     CASE
	 WHEN SALES > 50 THEN 'HIGH'
	 WHEN SALES <= 50 AND SALES > 20 THEN 'MEDIUM'
	 ELSE 'LOW'
	 END AS CATEGORY,
	 SUM(SALES)
	FROM SALES.ORDERS 
	GROUP BY (CASE
	 WHEN SALES > 50 THEN 'HIGH'
	 WHEN SALES <= 50 AND SALES > 20 THEN 'MEDIUM'
	 ELSE 'LOW'
	 END)
	 ORDER BY SUM(SALES) DESC

SELECT 
	CATEGORY,
	SUM(SALES) NEW_SALES
	FROM
(
SELECT 
	ORDERID,
	SALES,
	CASE
	WHEN SALES > 50 THEN 'HIGH'
	WHEN SALES > 20 THEN 'MEDIUM'
	ELSE 'LOW'
	END CATEGORY
	FROM SALES.ORDERS
)t
GROUP BY CATEGORY
ORDER BY NEW_SALES
		-- SQL AGGREGATION FUNCTION--
		--COUNT, SUM, AVG,MAX,MIN,

		-- WINDOW FUNCTION-- 
	--FIND TOTAL SALES ACROSS ALL ORDER
SELECT
	ORDERID,
	PRODUCTID,
	SALES,
	SUM(SALES) OVER(PARTITION BY PRODUCTID)
	FROM SALES.Orders
	
	
	
	
	SO
	LEFT JOIN SALES.CUSTOMERS SC
	ON  SO.CustomerID = SC.CustomerID







SELECT  
(ORDERDATE)
	FROM
SELECT 
	convert(orderdate,6)
	from sales.orders
		
		-- Window Functions
		/* Aggregate Function
		 Count, Sum, Avg, Min, Max 
		 -- Rank Function
		 Row_Number, Rank, Dense_Rank, Cume_Dist, Percent_Rank,Ntile
		 --Value(Analytics) Functions
		 -- Lead, Lag, First_Value, Last_Value*/

SELECT 
	CUSTOMERID,
	SALES,
	SUM(SALES) OVER( PARTITION BY PRODUCTID ORDER BY  SALES DESC) AS CUMMULATIVE_SALES
	FROM SALES.ORDERS

	--ROWS BETWEEN CURRENT ROW AND UNBOUNDED PRECEDING--
	-- N PRECEDING AND N FOLLOWING
	-- UNBOUNDED FOLLOWING
	 
SELECT 
	CustomerID,
	SUM(SALES) TOTAL_SALES,
	RANK() OVER(ORDER BY SUM(SALES) DESC) RANK_
	FROM SALES.ORDERS
	GROUP BY CustomerID
   
-- FIND THE TOTAL NUMBER OF CUSTOMERS, ADDITIONALLY PROVIDE ALL CUSTOMER'S DETAILS
SELECT *,
	COUNT(*) OVER(),
	COUNT(SCORE) OVER(),
	COUNT(COUNTRY) OVER()
	FROM SALES.CUSTOMERS
	GROUP BY COUNTRY
-- FIND THE HIGHEST & LOWEST SALES ACROSS ALL ORDERS AND THE HIGHEST & LOWEST SALES FOR EACH PRODUCT
-- ADDITIONALLY PROVIDE DETAILS SUCH ORDERID, ORDERDATE
SELECT 
	ORDERID,
	ORDERDATE,
	SALES,
	PRODUCTID,
	MAX(SALES) OVER() MAX_SALES,
	MIN(SALES) OVER() MIN_SALES,
	MAX(SALES) OVER(PARTITION BY PRODUCTID) MAX_PRODUCT,
	MIN(SALES) OVER(PARTITION BY PRODUCTID) MIN_PRODUCT
	FROM SALES.ORDERS

	SELECT
	* FROM
(SELECT 
	*,
	MAX(SALES) OVER() MAX_SALES
	FROM SALES.Orders)t
	WHERE SALES = MAX_SALES
	-- FIND THE DEVIATION OF EACH SALES FROM THE MINIMIUM AND MAXIMUM SALES AMOUNTS
SELECT 
	ORDERID,
	SALES,
	MAX(SALES) OVER( )MAX_SALES,
	MIN(SALES) OVER() MIN_SALES,
	MAX(SALES) OVER( ) - SALES DEVIATIONFROMMAX,
	SALES- MIN(SALES) OVER() DEVIATIONFROMMIN
	FROM SALES.ORDERS

--CALCULATE MOVING AVERAGE OF SALES FOR EACH PRODUCT OVER TIME
SELECT 
	ORDERID,
	ORDERDATE,
	PRODUCTID,
	Sales,
	AVG(SALES) OVER(PARTITION BY PRODUCTID) AVGSALES,
	AVG(SALES) OVER(PARTITION BY PRODUCTID ORDER BY ORDERDATE) MOVINGAVG
	FROM SALES.ORDERS
---CALCULATE MOVING AVERAGE OF SALES FOR EACH PRODUCT OVER TIME, INCLUDING ONLT THE NEXT ORDER

SELECT 
	ORDERID,
	ORDERDATE,
	PRODUCTID,
	SALES,
	AVG(SALES) OVER(PARTITION BY PRODUCTID) AVGSALES,
	AVG(SALES) OVER(PARTITION BY PRODUCTID ORDER BY ORDERDATE ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) MOVINGAVG
	FROM SALES.ORDERS

	--RANK FUNCTIONS (NO EXPRESSION)
	--1.INTEGER BASED RANKING (WITH THE POSTION)E.G TOP 3 PRODUCT
	--RANK,ROW_NUMBER,DENSE_RANK,NTILE() 
	--2. PERCENTAGE BASED RANKING( CONTRIBUTION TO THE OVERALL) FIND TOP 20% PRODUCT
    --CUME_DIST,PERCENT_RANK
	--FIND THE HIGHEST SALES FOR EACH PRODUCT
SELECT *
	FROM
(SELECT 
	ORDERID,
	ORDERDATE,
	SALES,
	PRODUCTID,
	ROW_NUMBER () OVER(PARTITION BY PRODUCTID ORDER BY SALES DESC) ROWNUMERRANKING,
	RANK() OVER(PARTITION BY PRODUCTID ORDER BY SALES DESC) RANKNUMBER,
	DENSE_RANK() OVER(PARTITION BY PRODUCTID ORDER BY SALES DESC) DENSERANKNUMBER
	FROM SALES.ORDERS)T WHERE ROWNUMERRANKING =1
	-- FIND THE LOWEST CUSTOMERS SALES BASED ON THEIR TOTAL SALES
SELECT *
	FROM
(SELECT 
	CUSTOMERID,
	SUM(SALES), 
	ROW_NUMBER() OVER(ORDER BY SUM(SALES)) RANKCUSTOMERS
	FROM SALES.ORDERS
	GROUP BY CUSTOMERID)t WHERE RANKCUSTOMERS <= 2
	


	-- SHOW THE EMPLOYEES WITH THE HIGHEST SALARIES
SELECT * 
	FROM
(	SELECT 
	*,
	MAX(SALARY) OVER() HIGHEST_SALARIES
	FROM SALES.EMPLOYEES)t
	WHERE SALARY = HIGHEST_SALARIES

-- NTILE--
SELECT 
	ORDERID,
	SALES ,
	NTILE(1) OVER (ORDER BY SALES DESC) ONEBUCKET,
	NTILE(2) OVER(ORDER BY SALES DESC) TWOBUCKET,
	NTILE(3) OVER (ORDER BY SALES DESC) THREEBUCKET,
	NTILE(4) OVER (ORDER BY SALES DESC) FOURBUCKET
	FROM SALES.ORDERS


	-- SEGMENT ALL ORDERS INTO 3 CATEGORIES: HIGH, MEDIUM & LOW SALES
SELECT 
	*,
	CASE
	WHEN SEGMENT3 =1 THEN 'HIGH'
	WHEN SEGMENT3 =2 THEN 'MEDIUM'
	ELSE 'LOW'
	END CATEGORY
FROM
(SELECT
	ORDERID,
	ORDERDATE,
	SALES,
	NTILE(3) OVER( ORDER BY SALES DESC) SEGMENT3
	FROM SALES.ORDERS)t 

	-- PERCENTAGE BASED RANKING FUNCTIONS
	--CUME_DIST(CUMMULATIVE DISTRIBUTION)= POSTION NUMBER OF THE VALUE / NUMBER OF ROWS 
	--& PERCENT_RANK= RELATIVE POSITION OF EACH OF THE ROW
	--FIND THE PRODUCTS THAT FALL WITHIN THE HIGHEST 40% OF PRICE
SELECT *
	FROM
(SELECT *,
	PERCENT_RANK() OVER(ORDER BY PRICE) PERCENTPRICE
	FROM SALES.PRODUCTS)t 
	WHERE PERCENTPRICE <= 0.4

SELECT *,
	CONCAT(PERCENTPRICE*100,'%')
	FROM
(SELECT *,
	CUME_DIST() OVER(ORDER BY PRICE) PERCENTPRICE
	FROM SALES.PRODUCTS)t 
	WHERE PERCENTPRICE <= 0.4 

	-- WINDOW ANALYTICAL FUNCTIONS(VALUE FUNCTIONS)
	--LAST_VALUE, FIRST_VALUE ,LAG,LEAD 
	-- ANALYZE THE MONTH-OVER-MONTH(MOM) PERFORMANCE BY FINDING THE PERCENTAGE CHANGE IN SALES

	--SYNTAX FOR LEAD & LAG
	--LEAD OR LAG(EXPRESSION,OFFSET,DEFAULT) OVER(PARTITION/ORDER BY ONLY) NO FRAME CLAUSE
SELECT *,
		TOTALSALES-TOTAL_PREVIOUS_SALES AS MOM_CHANGE,
	   ROUND(CAST(( TOTALSALES-TOTAL_PREVIOUS_SALES)AS FLOAT)/TOTAL_PREVIOUS_SALES*100,1) AS PERCENTCHANGE_SALES
	   FROM
(SELECT
	MONTH(ORDERDATE) MONTH,
	SUM(SALES) TOTALSALES, 
	LAG(SUM(SALES)) OVER(ORDER BY MONTH(ORDERDATE)) TOTAL_PREVIOUS_SALES
	FROM SALES.Orders
	GROUP BY MONTH(ORDERDATE))t

	--CUSTOMER RETENTION ANALYSIS
	-- MEASURE CUSTOMER'S BEHAVIOR AND LOYALTY TO HELP BUSINESSES BUILD STRONG 
	--RELATIONSHIPS WITH CUSTOMERS

	--Q1. ANALYZE CUSTOMER LOYALTY BY RANKING CUSTOMERS BASED ON THE AVERAGE NUMBER OF DAYS BETWEEN ORDERS
SELECT 
	CUSTOMERID,
	AVG(DIFFDAY) AS AVGDAYS,
	RANK() OVER(ORDER BY ISNULL(AVG(DIFFDAY),99999)) RANKAVGDAYS
	FROM
(SELECT 
	ORDERID,
	CUSTOMERID,
	ORDERDATE AS CURRENTDATE,
	LEAD(ORDERDATE) OVER (PARTITION BY CUSTOMERID ORDER BY ORDERDATE) NEXTDATE,
	DATEDIFF(DAY,ORDERDATE,LEAD(ORDERDATE) OVER (PARTITION BY CUSTOMERID ORDER BY ORDERDATE)) DIFFDAY
	FROM SALES.ORDERS)t
	GROUP BY CustomerID
	-- FIRST_VALUE FROM THE FIRST ROW WITHIN THE WINDOW
	-- LAST_VALUE , THE LAST ROW WITHIIN THE WINDOW
	--LAST_VALUE(EXPRESSION)OVER(*)
	--FIND THE HIGHEST AND LOWEST SALES FOR EACH PRODUCT
SELECT *
	FROM
(SELECT
	ORDERID,
	PRODUCTID,
	SALES,
	FIRST_VALUE(SALES) OVER(PARTITION BY PRODUCTID ORDER BY SALES) LOWESTSALES,
	LAST_VALUE(SALES) OVER(PARTITION BY PRODUCTID ORDER BY SALES ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) HIGHESTSALES
	FROM SALES.ORDERS)t
	WHERE SALES = LOWESTSALES OR SALES = HIGHESTSALES

	  --OR
SELECT *
	FROM
	(SELECT
	ORDERID,
	PRODUCTID,
	SALES,
	MIN(SALES) OVER(PARTITION BY PRODUCTID ) LOWESTSALES,
	MAX(SALES) OVER(PARTITION BY PRODUCTID ) HIGHESTSALES
	FROM SALES.ORDERS)t
	WHERE SALES = LOWESTSALES OR SALES = HIGHESTSALES

	-- FIND THE DIFFERENCE IN SALES THE CURRENT AND LOWEST SALES
SELECT
	ORDERID,
	SALES,
	LOWESTSALES,
	SALES-LOWESTSALES AS SALESDIFF
	FROM
(SELECT
	ORDERID,
	PRODUCTID,
	SALES,
	MIN(SALES) OVER(PARTITION BY PRODUCTID ) LOWESTSALES,
	MAX(SALES) OVER(PARTITION BY PRODUCTID ) HIGHESTSALES
	FROM SALES.ORDERS)t
	
	

	
	
	

SELECT *
	FROM SALES.CUSTOMERS

SELECT 
	SALES,
	COUNT(SALES)
	FROM SALES.ORDERS
	GROUP BY SALES

SELECT *
	FROM SALES.EMPLOYEES

SELECT *
	FROM SALES.PRODUCTS

		 




